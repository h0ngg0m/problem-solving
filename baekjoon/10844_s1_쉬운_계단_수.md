## 내 솔루션
```python
import sys
n = int(sys.stdin.readline())
dp = [[0] * 10 for _ in range(n)]
dp[0] = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1]

for i in range(1, n):
    dp[i][0] = dp[i - 1][1]
    dp[i][9] = dp[i - 1][8]
    for j in range(1, 9):
        dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1])

print(sum(dp[n - 1]) % 1_000_000_000)
```
우선 어느정도 시간을 가지고 풀었으나 풀지 못하여 다른 풀이를 참고하였고 이해하는 방식으로 진행했다.

아래 표를 보면 각 자릿수에 올 수 있는 경우의 수를 3자릿수까지 적어놓은 것이다.

```python
            각 자릿수에서 가장 뒤에 오는 숫자(0~9)
            0  1  2  3  4  5  6  7  8  9
  자릿수(0)   0  0  0  0  0  0  0  0  0  0
  자릿수(1)   0  1  1  1  1  1  1  1  1  1
  자릿수(2)   1  1  2  2  2  2  2  2  2  1
  자릿수(3)   1  3  3  4  4  4  4  4  3  2
```

케이스는 3가지가 있다.

1. 마지막 숫자가 0인 경우
2. 마지막 숫자가 9인 경우
3. 나머지

### 마지막 숫자가 0인 경우
마지막 숫자가 0인 경우는 `dp[i][0] = dp[i - 1][1]` 이렇게 구할 수 있다. 왜 그럴까? 잘 생각해보면 마지막 숫자가 0인 경우에는 0앞에 무조건 1이 와야한다. 그렇다면 0인 
경우의 케이스를 구하는 것은 앞의 숫자가 1인 경우의 수를 구하는 것과 같다. 만약 4자릿수의 케이스에서 마지막 숫자가 0이면 앞에 숫자가 1이면서 3자릿수의 케이스를 구하는 것과 같다 즉,
`dp[i - 1][1]`의 수와 같을 수밖에 없다.

### 마지막 숫자가 9인 경우
위 0인 경우를 구하는 것과 거의 똑같은 방식이다. 마지막 숫자가 9면 그 앞에는 8밖에 올 수 없다. 그렇기 때문에 `dp[i - 1][8]`의 수와 같다.

### 나머지
마지막 숫자가 0 또는 9 가 아니라면 그 숫자 앞에는 +1된 숫자 -1된 숫자가 올 수 있다. 근데 그와 동시에 현재 구하는 자릿수 -1에서 +1, -1이 된 값을 더하면 된다. 즉 `dp[i - 1][j - 1] + dp[i - 1][j + 1]`의 수와 같다. 


## 문제 내용
### 문제
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

### 입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

### 출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.